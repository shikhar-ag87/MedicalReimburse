import { SupabaseConnection } from "@/database/providers/supabase";
import {
    MedicalApplication,
    CreateMedicalApplicationData,
    UpdateMedicalApplicationData,
    MedicalApplicationRepository,
} from "@/types/database";
import { logger } from "@/utils/logger";
import { v4 as uuidv4 } from "uuid";

export class SupabaseMedicalApplicationRepository
    implements MedicalApplicationRepository
{
    constructor(private db: SupabaseConnection) {}

    async create(
        data: CreateMedicalApplicationData
    ): Promise<MedicalApplication> {
        const client = this.db.getClient();

        const applicationData = {
            id: uuidv4(),
            application_number: "", // Will be auto-generated by trigger
            status: data.status || "pending",
            employee_name: data.employeeName,
            employee_id: data.employeeId,
            designation: data.designation,
            department: data.department,
            cghs_card_number: data.cghsCardNumber,
            cghs_dispensary: data.cghsDispensary,
            card_validity: data.cardValidity,
            ward_entitlement: data.wardEntitlement,
            patient_name: data.patientName,
            patient_cghs_card: data.patientCghsCard,
            relationship_with_employee: data.relationshipWithEmployee,
            hospital_name: data.hospitalName,
            hospital_address: data.hospitalAddress,
            treatment_type: data.treatmentType,
            clothes_provided: data.clothesProvided,
            prior_permission: data.priorPermission,
            permission_details: data.permissionDetails,
            emergency_treatment: data.emergencyTreatment,
            emergency_details: data.emergencyDetails,
            health_insurance: data.healthInsurance,
            insurance_amount: data.insuranceAmount,
            total_amount_claimed: data.totalAmountClaimed || 0,
            total_amount_passed: data.totalAmountPassed || 0,
            bank_name: data.bankName,
            branch_address: data.branchAddress,
            account_number: data.accountNumber,
            ifsc_code: data.ifscCode,
            enclosures_count: data.enclosuresCount || 0,
            photocopy_cghs_card: data.photocopyCGHSCard,
            photocopies_original_prescriptions:
                data.photocopiesOriginalPrescriptions,
            original_bills: data.originalBills,
            signature: data.signature,
            declaration_place: data.declarationPlace,
            declaration_date: data.declarationDate,
            faculty_employee_id: data.facultyEmployeeId,
            mobile_number: data.mobileNumber,
            email: data.email,
        };

        const { data: result, error } = await client
            .from("medical_applications")
            .insert([applicationData])
            .select("*")
            .single();

        if (error) {
            logger.error("Failed to create medical application:", error);
            throw new Error(`Failed to create application: ${error.message}`);
        }

        return this.mapFromDatabase(result);
    }

    async findById(id: string): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const { data, error } = await client
            .from("medical_applications")
            .select("*")
            .eq("id", id)
            .single();

        if (error) {
            if (error.code === "PGRST116") {
                // Not found
                return null;
            }
            logger.error("Failed to find application by ID:", error);
            throw new Error(`Failed to find application: ${error.message}`);
        }

        return this.mapFromDatabase(data);
    }

    async findAll(
        filters?: Partial<MedicalApplication>
    ): Promise<MedicalApplication[]> {
        const client = this.db.getClient();
        let query = client.from("medical_applications").select("*");

        // Apply filters
        if (filters?.status) {
            query = query.eq("status", filters.status);
        }
        if (filters?.employeeId) {
            query = query.eq("employee_id", filters.employeeId);
        }
        if (filters?.department) {
            query = query.eq("department", filters.department);
        }

        query = query.order("submitted_at", { ascending: false });

        const { data, error } = await query;

        if (error) {
            logger.error("Failed to find applications:", error);
            throw new Error(`Failed to find applications: ${error.message}`);
        }

        return data?.map((item) => this.mapFromDatabase(item)) || [];
    }

    async update(
        id: string,
        data: Partial<UpdateMedicalApplicationData>
    ): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const updateData: any = {};

        // Map update data to database columns
        if (data.status) updateData.status = data.status;
        if (data.reviewComments)
            updateData.review_comments = data.reviewComments;
        if (data.totalAmountPassed !== undefined)
            updateData.total_amount_passed = data.totalAmountPassed;

        const { data: result, error } = await client
            .from("medical_applications")
            .update(updateData)
            .eq("id", id)
            .select("*")
            .single();

        if (error) {
            logger.error("Failed to update application:", error);
            throw new Error(`Failed to update application: ${error.message}`);
        }

        return this.mapFromDatabase(result);
    }

    async delete(id: string): Promise<boolean> {
        const client = this.db.getClient();

        const { error } = await client
            .from("medical_applications")
            .delete()
            .eq("id", id);

        if (error) {
            logger.error("Failed to delete application:", error);
            throw new Error(`Failed to delete application: ${error.message}`);
        }

        return true;
    }

    async count(filters?: Partial<MedicalApplication>): Promise<number> {
        const client = this.db.getClient();
        let query = client
            .from("medical_applications")
            .select("*", { count: "exact", head: true });

        // Apply filters
        if (filters?.status) {
            query = query.eq("status", filters.status);
        }
        if (filters?.employeeId) {
            query = query.eq("employee_id", filters.employeeId);
        }

        const { count, error } = await query;

        if (error) {
            logger.error("Failed to count applications:", error);
            throw new Error(`Failed to count applications: ${error.message}`);
        }

        return count || 0;
    }

    async findByEmployeeId(employeeId: string): Promise<MedicalApplication[]> {
        return this.findAll({ employeeId });
    }

    async findByStatus(
        status: MedicalApplication["status"]
    ): Promise<MedicalApplication[]> {
        return this.findAll({ status });
    }

    async findByApplicationNumber(
        applicationNumber: string
    ): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const { data, error } = await client
            .from("medical_applications")
            .select("*")
            .eq("application_number", applicationNumber)
            .single();

        if (error) {
            if (error.code === "PGRST116") {
                // Not found
                return null;
            }
            logger.error("Failed to find application by number:", error);
            throw new Error(`Failed to find application: ${error.message}`);
        }

        return this.mapFromDatabase(data);
    }

    async updateStatus(
        id: string,
        status: MedicalApplication["status"],
        reviewerId?: string,
        comments?: string
    ): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const updateData: any = {
            status,
            updated_at: new Date().toISOString(),
        };

        if (reviewerId) {
            updateData.reviewed_by = reviewerId;
            updateData.reviewed_at = new Date().toISOString();
        }

        if (comments) {
            updateData.review_comments = comments;
        }

        const { data: result, error } = await client
            .from("medical_applications")
            .update(updateData)
            .eq("id", id)
            .select("*")
            .single();

        if (error) {
            logger.error("Failed to update application status:", error);
            throw new Error(
                `Failed to update application status: ${error.message}`
            );
        }

        return this.mapFromDatabase(result);
    }

    async getApplicationsForReview(): Promise<MedicalApplication[]> {
        return this.findByStatus("pending");
    }

    async getApplicationStats(): Promise<{
        total: number;
        pending: number;
        approved: number;
        rejected: number;
        completed: number;
    }> {
        const [total, pending, approved, rejected, completed] =
            await Promise.all([
                this.count(),
                this.count({ status: "pending" }),
                this.count({ status: "approved" }),
                this.count({ status: "rejected" }),
                this.count({ status: "completed" }),
            ]);

        return { total, pending, approved, rejected, completed };
    }

    private mapFromDatabase(data: any): MedicalApplication {
        return {
            id: data.id,
            applicationNumber: data.application_number,
            status: data.status,
            submittedAt: new Date(data.submitted_at),
            updatedAt: new Date(data.updated_at),
            employeeName: data.employee_name,
            employeeId: data.employee_id,
            designation: data.designation,
            department: data.department,
            cghsCardNumber: data.cghs_card_number,
            cghsDispensary: data.cghs_dispensary,
            cardValidity: new Date(data.card_validity),
            wardEntitlement: data.ward_entitlement,
            patientName: data.patient_name,
            patientCghsCard: data.patient_cghs_card,
            relationshipWithEmployee: data.relationship_with_employee,
            hospitalName: data.hospital_name,
            hospitalAddress: data.hospital_address,
            treatmentType: data.treatment_type,
            clothesProvided: data.clothes_provided,
            priorPermission: data.prior_permission,
            permissionDetails: data.permission_details,
            emergencyTreatment: data.emergency_treatment,
            emergencyDetails: data.emergency_details,
            healthInsurance: data.health_insurance,
            insuranceAmount: data.insurance_amount,
            totalAmountClaimed: parseFloat(data.total_amount_claimed) || 0,
            totalAmountPassed: parseFloat(data.total_amount_passed) || 0,
            bankName: data.bank_name,
            branchAddress: data.branch_address,
            accountNumber: data.account_number,
            ifscCode: data.ifsc_code,
            enclosuresCount: data.enclosures_count,
            photocopyCGHSCard: data.photocopy_cghs_card,
            photocopiesOriginalPrescriptions:
                data.photocopies_original_prescriptions,
            originalBills: data.original_bills,
            signature: data.signature,
            declarationPlace: data.declaration_place,
            declarationDate: new Date(data.declaration_date),
            facultyEmployeeId: data.faculty_employee_id,
            mobileNumber: data.mobile_number,
            email: data.email,
            reviewedBy: data.reviewed_by,
            reviewedAt: data.reviewed_at
                ? new Date(data.reviewed_at)
                : undefined,
            reviewComments: data.review_comments,
            processedBy: data.processed_by,
            processedAt: data.processed_at
                ? new Date(data.processed_at)
                : undefined,
        };
    }
}
