import { SupabaseConnection } from "../../providers/supabase";
import {
    MedicalApplication,
    CreateMedicalApplicationData,
    UpdateMedicalApplicationData,
    MedicalApplicationRepository,
} from "../../../types/database";
import { logger } from "../../../utils/logger";
import { v4 as uuidv4 } from "uuid";

export class SupabaseMedicalApplicationRepository
    implements MedicalApplicationRepository
{
    constructor(private db: SupabaseConnection) {}

    async create(
        data: CreateMedicalApplicationData
    ): Promise<MedicalApplication> {
        const client = this.db.getClient();

        const applicationData = {
            id: uuidv4(),
            application_number: "", // Will be auto-generated by trigger
            status: data.status || "pending",
            employee_name: data.employeeName,
            employee_id: data.employeeId,
            designation: data.designation,
            department: data.department,
            cghs_card_number: data.cghsCardNumber,
            cghs_dispensary: data.cghsDispensary,
            card_validity: data.cardValidity,
            ward_entitlement: data.wardEntitlement,
            patient_name: data.patientName,
            patient_cghs_card: data.patientCghsCard,
            relationship_with_employee: data.relationshipWithEmployee,
            hospital_name: data.hospitalName,
            hospital_address: data.hospitalAddress,
            treatment_type: data.treatmentType,
            clothes_provided: data.clothesProvided,
            prior_permission: data.priorPermission,
            permission_details: data.permissionDetails,
            emergency_treatment: data.emergencyTreatment,
            emergency_details: data.emergencyDetails,
            health_insurance: data.healthInsurance,
            insurance_amount: data.insuranceAmount,
            total_amount_claimed: data.totalAmountClaimed || 0,
            approved_amount: data.totalAmountPassed || 0,
            bank_name: data.bankName,
            branch_address: data.branchAddress,
            account_number: data.accountNumber,
            ifsc_code: data.ifscCode,
            enclosures_count: data.enclosuresCount || 0,
            photocopy_cghs_card: data.photocopyCGHSCard,
            photocopies_original_prescriptions:
                data.photocopiesOriginalPrescriptions,
            original_bills: data.originalBills,
            signature: data.signature,
            declaration_place: data.declarationPlace,
            declaration_date: data.declarationDate,
            faculty_employee_id: data.facultyEmployeeId,
            mobile_number: data.mobileNumber,
            email: data.email,
        };

        const { data: result, error } = await client
            .from("medical_applications")
            .insert([applicationData])
            .select("*")
            .single();

        if (error) {
            logger.error("Failed to create medical application:", error);
            throw new Error(`Failed to create application: ${error.message}`);
        }

        return this.mapFromDatabase(result);
    }

    async findById(id: string): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const { data, error } = await client
            .from("medical_applications")
            .select("*")
            .eq("id", id)
            .single();

        if (error) {
            if (error.code === "PGRST116") {
                // Not found
                return null;
            }
            logger.error("Failed to find application by ID:", error);
            throw new Error(`Failed to find application: ${error.message}`);
        }

        return this.mapFromDatabase(data);
    }

    async findAll(
        filters?: Partial<MedicalApplication>
    ): Promise<MedicalApplication[]> {
        const client = this.db.getClient();
        let query = client.from("medical_applications").select("*");

        // Apply filters
        if (filters?.status) {
            query = query.eq("status", filters.status);
        }
        if (filters?.employeeId) {
            query = query.eq("employee_id", filters.employeeId);
        }
        if (filters?.department) {
            query = query.eq("department", filters.department);
        }

        query = query.order("submitted_at", { ascending: false });

        const { data, error } = await query;

        if (error) {
            logger.error("Failed to find applications:", error);
            throw new Error(`Failed to find applications: ${error.message}`);
        }

        return data?.map((item) => this.mapFromDatabase(item)) || [];
    }

    async update(
        id: string,
        data: Partial<UpdateMedicalApplicationData>
    ): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const updateData: any = {};

        // Map update data to database columns
        if (data.status) updateData.status = data.status;
        if (data.totalAmountPassed !== undefined)
            updateData.approved_amount = data.totalAmountPassed;
        if (data.totalAmountClaimed !== undefined)
            updateData.total_amount_claimed = data.totalAmountClaimed;

        const { data: result, error } = await client
            .from("medical_applications")
            .update(updateData)
            .eq("id", id)
            .select("*")
            .single();

        if (error) {
            logger.error("Failed to update application:", error);
            throw new Error(`Failed to update application: ${error.message}`);
        }

        return this.mapFromDatabase(result);
    }

    async delete(id: string): Promise<boolean> {
        const client = this.db.getClient();

        const { error } = await client
            .from("medical_applications")
            .delete()
            .eq("id", id);

        if (error) {
            logger.error("Failed to delete application:", error);
            throw new Error(`Failed to delete application: ${error.message}`);
        }

        return true;
    }

    async count(filters?: Partial<MedicalApplication>): Promise<number> {
        const client = this.db.getClient();
        let query = client
            .from("medical_applications")
            .select("*", { count: "exact", head: true });

        // Apply filters
        if (filters?.status) {
            query = query.eq("status", filters.status);
        }
        if (filters?.employeeId) {
            query = query.eq("employee_id", filters.employeeId);
        }

        const { count, error } = await query;

        if (error) {
            logger.error("Failed to count applications:", error);
            throw new Error(`Failed to count applications: ${error.message}`);
        }

        return count || 0;
    }

    async findByEmployeeId(employeeId: string): Promise<MedicalApplication[]> {
        return this.findAll({ employeeId });
    }

    async findByStatus(
        status: MedicalApplication["status"]
    ): Promise<MedicalApplication[]> {
        return this.findAll({ status });
    }

    async findByApplicationNumber(
        applicationNumber: string
    ): Promise<MedicalApplication | null> {
        const client = this.db.getClient();

        const { data, error } = await client
            .from("medical_applications")
            .select("*")
            .eq("application_number", applicationNumber)
            .single();

        if (error) {
            if (error.code === "PGRST116") {
                // Not found
                return null;
            }
            logger.error("Failed to find application by number:", error);
            throw new Error(`Failed to find application: ${error.message}`);
        }

        return this.mapFromDatabase(data);
    }

    async updateStatus(
        id: string,
        status: MedicalApplication["status"],
        reviewerId?: string,
        comments?: string
    ): Promise<MedicalApplication | null> {
        // Use service client for admin operations to bypass RLS
        const client = this.db.getServiceClient ? this.db.getServiceClient() : this.db.getClient();

        // Only update core fields that exist in the Supabase schema
        // reviewed_by, reviewed_at, and admin_remarks are tracked elsewhere (application_reviews table)
        const updateData: any = {
            status,
            updated_at: new Date().toISOString(),
        };

        console.log("üîÑ UPDATE STATUS - ID:", id, "| New Status:", status);

        // First, verify the row exists and check RLS
        const { data: existingCheck, error: checkError } = await client
            .from("medical_applications")
            .select("id, status")
            .eq("id", id);

        console.log("üìã Pre-update check:", { 
            found: existingCheck?.length, 
            currentStatus: existingCheck?.[0]?.status,
            checkError: checkError?.message,
            usingServiceClient: !!this.db.getServiceClient
        });

        if (!existingCheck || existingCheck.length === 0) {
            console.error("‚ùå CRITICAL: Application not found or RLS blocking access");
            logger.error("Application not accessible for update:", { id, checkError });
            throw new Error("Application not found or access denied. Check RLS policies.");
        }

        const { data: result, error } = await client
            .from("medical_applications")
            .update(updateData)
            .eq("id", id)
            .select("*");

        console.log("‚úÖ Update result:", { 
            rowsUpdated: result?.length, 
            newStatus: result?.[0]?.status,
            error: error?.message 
        });

        if (error) {
            console.error("‚ùå Update error:", error);
            logger.error("Failed to update application status:", error);
            throw new Error(
                `Failed to update application status: ${error.message}`
            );
        }

        if (!result || result.length === 0) {
            console.error("‚ùå No rows updated - likely RLS policy issue");
            logger.error("No application found with id:", id);
            return null;
        }

        return this.mapFromDatabase(result[0]);
    }

    async getApplicationsForReview(): Promise<MedicalApplication[]> {
        return this.findByStatus("pending");
    }

    async getApplicationStats(): Promise<{
        total: number;
        pending: number;
        approved: number;
        rejected: number;
        completed: number;
    }> {
        // Get all applications to count statuses manually
        const allApplications = await this.findAll();
        
        const total = allApplications.length;
        const pending = allApplications.filter(a => a.status === "pending").length;
        // Count both "approved" (awaiting Super Admin) and "reimbursed" (approved by Super Admin)
        const approved = allApplications.filter(a => a.status === "approved" || a.status === "reimbursed").length;
        const rejected = allApplications.filter(a => a.status === "rejected").length;
        const completed = allApplications.filter(a => a.status === "completed" || a.status === "reimbursed").length;

        return { total, pending, approved, rejected, completed };
    }

    private mapFromDatabase(data: any): MedicalApplication {
        const result: MedicalApplication = {
            id: data.id,
            applicationNumber: data.application_number,
            status: data.status,
            submittedAt: new Date(data.submitted_at),
            updatedAt: new Date(data.updated_at),
            employeeName: data.employee_name,
            employeeId: data.employee_id,
            designation: data.designation,
            department: data.department,
            cghsCardNumber: data.cghs_card_number,
            cghsDispensary: data.cghs_dispensary,
            cardValidity: new Date(data.card_validity),
            wardEntitlement: data.ward_entitlement,
            patientName: data.patient_name,
            patientCghsCard: data.patient_cghs_card,
            relationshipWithEmployee: data.relationship_with_employee,
            hospitalName: data.hospital_name,
            hospitalAddress: data.hospital_address,
            treatmentType: data.treatment_type,
            clothesProvided: data.clothes_provided,
            priorPermission: data.prior_permission,
            emergencyTreatment: data.emergency_treatment,
            healthInsurance: data.health_insurance,
            totalAmountClaimed: parseFloat(data.total_amount_claimed) || 0,
            totalAmountPassed: parseFloat(data.approved_amount) || 0,
            bankName: data.bank_name,
            branchAddress: data.branch_address,
            accountNumber: data.account_number,
            ifscCode: data.ifsc_code,
            enclosuresCount: data.enclosures_count,
            photocopyCGHSCard: data.photocopy_cghs_card,
            photocopiesOriginalPrescriptions:
                data.photocopies_original_prescriptions,
            originalBills: data.original_bills,
            signature: data.signature,
            declarationPlace: data.declaration_place,
            declarationDate: new Date(data.declaration_date),
            facultyEmployeeId: data.faculty_employee_id,
            mobileNumber: data.mobile_number,
            email: data.email,
        };

        // Handle optional fields properly
        if (data.permission_details) {
            result.permissionDetails = data.permission_details;
        }

        if (data.emergency_details) {
            result.emergencyDetails = data.emergency_details;
        }

        if (data.insurance_amount) {
            result.insuranceAmount = data.insurance_amount;
        }

        if (data.reviewed_by) {
            result.reviewedBy = data.reviewed_by;
        }

        if (data.reviewed_at) {
            result.reviewedAt = new Date(data.reviewed_at);
        }

        if (data.review_comments) {
            result.reviewComments = data.review_comments;
        }

        if (data.processed_by) {
            result.processedBy = data.processed_by;
        }

        if (data.processed_at) {
            result.processedAt = new Date(data.processed_at);
        }

        return result;
    }
}
